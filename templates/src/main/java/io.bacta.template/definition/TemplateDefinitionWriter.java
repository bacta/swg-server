package io.bacta.template.definition;

import io.bacta.engine.utils.StringUtil;

import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static io.bacta.template.definition.TemplateData.*;

/**
 * Created by crush on 4/19/2016.
 * <p>
 * Takes a TemplateDefinitionFile and writes the specified version to a file stream.
 */
public class TemplateDefinitionWriter {
    private String templatePackage;

    public TemplateDefinitionWriter(final String templatePackage) {
        this.templatePackage = templatePackage;
    }

    /**
     * Writes the template definition file to the specified buffer using the specified version.
     *
     * @param outputStream           The stream to which the file will be written.
     * @param templateDefinitionFile The template definition file to use.
     * @param version                The version to use.
     */
    public void write(final OutputStream outputStream, final TemplateDefinitionFile templateDefinitionFile, int version) {
        final PrintStream printStream = new PrintStream(outputStream);
        final TemplateData templateData = templateDefinitionFile.getTemplateData(version);

        printPackageAndIncludes(printStream);
        printClassComment(printStream);

        printClassDeclarationOpening(printStream, templateData);
        printTemplateTag(printStream, templateData);
        printClassConstructorRegistration(printStream, templateData);
        printFields(printStream, templateData);
        printConstructors(printStream, templateData);
        printMethods(printStream, templateData);
        printLoadMethod(printStream, templateData);
        printSaveMethod(printStream, templateData);
        printEnums(printStream, templateData);
        printStructs(printStream, templateData);
        printClassDeclarationClosing(printStream, templateData);
    }

    private void printPackageAndIncludes(final PrintStream printStream) {
        printStream.printf("package %s;\n", templatePackage);
        printStream.println();

        for (final String include : includes)
            printStream.printf("import %s;\n", include);

        printStream.println();
    }

    private void printClassComment(final PrintStream printStream) {
        printStream.printf("/**\n");
        printStream.printf(" * Generated by the %s.\n", getClass().getSimpleName());
        printStream.printf(" * MANUAL MODIFICATIONS MAY BE OVERWRITTEN.\n");
        printStream.printf(" */\n");
    }

    private void printClassDeclarationOpening(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        final String name = templateData.templateParent == null
                ? templateData.getName()
                : templateData.getName() + "ObjectTemplate";

        String baseName = templateData.getBaseName();

        if (baseName == null || baseName.isEmpty())
            baseName = TemplateUtil.ROOT_TEMPLATE_NAME;

        final String access = templateData.templateParent == null ? "public" : "protected static";

        //Demarcate the top level class with an annotation.
        if (templateData.fileParent != null)
            printStream.println("@TemplateDefinition");

        printStream.printf("%s%s class %s extends %s {\n", tabs, access, name, baseName);
        printStream.printf("\tprivate static final Logger LOGGER = LoggerFactory.getLogger(%s.class);\n", name);
    }

    private void printTemplateTag(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        final TagInfo tagInfo = templateData.fileParent != null
                ? templateData.fileParent.getTemplateId()
                : templateData.getStructId();

        printStream.printf("%s\tpublic static final int TAG_%s = Tag.convertStringToTag(\"%s\");\n",
                tabs,
                templateData.getName().toUpperCase(),
                TagInfo.convertTagToString(tagInfo.tag));
        printStream.println();
    }

    private void printClassConstructorRegistration(final PrintStream printStream, final TemplateData templateData) {
        printStream.printf("\tprivate static void registerTemplateConstructors(final DataResourceList<ObjectTemplate> objectTemplateList) {\n");
        printStream.printf("\t\tobjectTemplateList.registerTemplate(%s.TAG_%s, %s::new);\n",
                templateData.getName(),
                templateData.getName().toUpperCase(),
                templateData.getName());

        for (final TemplateData structData : templateData.structList) {
            printStream.printf("\t\tobjectTemplateList.registerTemplate(%sObjectTemplate.TAG_%s, %sObjectTemplate::new);\n",
                    structData.getName(),
                    structData.getName().toUpperCase(),
                    structData.getName());
        }

        printStream.printf("\t}\n");
        printStream.println();
    }

    private void printFields(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);
        final List<String> commentList = new ArrayList<>(templateData.parameters.size());

        if (templateData.fileParent != null) {
            printStream.printf("%s\tprivate int templateVersion;\n", tabs);
            printStream.println();
        }

        for (final TemplateData.Parameter parameter : templateData.parameters) {
            final String returnType = dataVariableNames[parameter.type.ordinal()];

            //Dump any queued comments.
            if (parameter.type != ParamType.COMMENT) {
                commentList.stream().forEachOrdered(
                        comment -> printStream.printf("%s\t%s\n", tabs, comment));
                commentList.clear();
            }

            switch (parameter.type) {
                case COMMENT:
                    commentList.add(parameter.description);
                    break;
                case INTEGER:
                case ENUM:
                case FLOAT:
                case BOOL:
                case STRING:
                case STRING_ID:
                case FILENAME:
                case VECTOR:
                case DYNAMIC_VAR:
                case TEMPLATE:
                case STRUCT:
                case TRIGGER_VOLUME:
                    final String comment = fixComment(parameter.description);

                    switch (parameter.listType) {
                        case NONE:
                            printStream.printf("%s\tprivate final %s %s = new %s(); %s\n",
                                    tabs, returnType, parameter.name, returnType, comment);
                            break;
                        case LIST:
                            printStream.printf("%s\tprivate final List<%s> %s = new ArrayList<>(); %s\n",
                                    tabs, returnType, parameter.name, comment);
                            printStream.printf("%s\tprivate boolean %sLoaded;\n", tabs, parameter.name);
                            printStream.printf("%s\tprivate boolean %sAppend;\n", tabs, parameter.name);
                            break;
                        case INT_ARRAY:
                        case ENUM_ARRAY:
                            printStream.printf("%s\tprivate final %s[] %s = new %s[] { %s\n",
                                    tabs, returnType, parameter.name, returnType, comment);

                            for (int i = 0, listSize = parameter.listSize; i < listSize; ++i)
                                printStream.printf("%s\t\tnew %s(),\n", tabs, returnType);

                            printStream.printf("%s\t};\n", tabs);
                            break;
                        default:
                            break;
                    }
                    break;
                case NONE:
                default:
                    break;
            }

            //Write out an loaded and append flag for list variables.
            switch (parameter.type) {
                case INTEGER:
                case FLOAT:
                case BOOL:
                case STRING:
                case STRING_ID:
                case FILENAME:
                case VECTOR:
                case DYNAMIC_VAR:
                case ENUM:
                case TEMPLATE:
                case STRUCT:
                case TRIGGER_VOLUME:
                    if (parameter.listType == TemplateData.ListType.LIST) {

                    }
                    break;
                case NONE:
                case COMMENT:
                default:
                    break;
            }
        }

        printStream.println();
    }

    private void printConstructors(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        final String name = templateData.templateParent == null
                ? templateData.getName()
                : templateData.getName() + "ObjectTemplate";

        printStream.printf("%s\tpublic %s(final String filename, final DataResourceList<ObjectTemplate> objectTemplateList) {\n",
                tabs, name);
        printStream.printf("%s\t\tsuper(filename, objectTemplateList);\n", tabs);
        printStream.printf("%s\t}\n", tabs);
        printStream.println();
    }

    private void printMethods(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        //Getter for the tag.
        printStream.printf("%s\t@Override\n", tabs);
        printStream.printf("%s\tpublic int getId() { return TAG_%s; }\n", tabs, templateData.getName().toUpperCase());
        printStream.println();

        for (final Parameter parameter : templateData.parameters) {
            if (parameter.type == ParamType.COMMENT || parameter.type == ParamType.NONE)
                continue;

            switch (parameter.type) {
                case INTEGER:
                case FLOAT:
                case BOOL:
                case STRING:
                case STRING_ID:
                case FILENAME:
                case TRIGGER_VOLUME:
                    printMethodForGenericParameter(printStream, templateData, parameter);
                    break;
                case VECTOR:
                    printMethodForVectorParameter(printStream, templateData, parameter);
                    break;
                case DYNAMIC_VAR:
                    printMethodForDynamicVariableParameter(printStream, templateData, parameter);
                    break;
                case TEMPLATE:
                    printMethodForTemplateParameter(printStream, templateData, parameter);
                    break;
                case ENUM:
                    printMethodForEnumParameter(printStream, templateData, parameter);
                    break;
                case STRUCT:
                    printMethodForStructParameter(printStream, templateData, parameter);
                    break;
            }

            //Write a getter for the count if it's a list.
            if (parameter.listType == ListType.LIST) {
                final String templateName = templateData.templateParent == null
                        ? templateData.getName()
                        : templateData.getName() + "ObjectTemplate";

                final String upperName = StringUtil.upperFirst(parameter.name);

                printStream.printf("%s\tpublic int get%sCount() {\n", tabs, upperName);
                printStream.printf("%s\t\tif (!%sLoaded) {\n", tabs, parameter.name);
                printStream.printf("%s\t\t\tif (baseData == null)\n", tabs);
                printStream.printf("%s\t\t\t\treturn 0;\n", tabs);
                printStream.println();
                printStream.printf("%s\t\tfinal %s base = (%s)baseData;\n", tabs, templateName, templateName);
                printStream.printf("%s\t\t\treturn base.get%sCount();\n", tabs, upperName);
                printStream.printf("%s\t\t}\n", tabs);
                printStream.println();
                printStream.printf("%s\t\tint count = %s.size();\n", tabs, parameter.name);
                printStream.println();
                printStream.printf("%s\t\tif (%sAppend && baseData != null) {\n", tabs, parameter.name);
                printStream.printf("%s\t\t\tfinal %s base = (%s)baseData;\n", tabs, templateName, templateName);
                printStream.printf("%s\t\t\tcount += base.get%sCount();\n", tabs, upperName);
                printStream.printf("%s\t\t}\n", tabs);
                printStream.println();
                printStream.printf("%s\t\treturn count;\n", tabs);
                printStream.printf("%s\t}\n", tabs);
                printStream.println();
            }
        }
    }

    private void printMethodArguments(final PrintStream printStream, final Parameter parameter) {
        switch (parameter.listType) {
            case LIST:
            case INT_ARRAY:
                printStream.printf("int index");
                break;
            case ENUM_ARRAY:
                printStream.printf("%s index", parameter.enumListName);
                break;
        }
    }

    private void printMethodForGenericParameter(final PrintStream printStream, final TemplateData templateData, final Parameter parameter) {
        final String returnType = dataMethodNames[parameter.type.ordinal()];
        final String arrayAccessor = getArrayAccessor(parameter.listType);
        final String indexString = parameter.listType != ListType.NONE ? "index" : "";
        final String upperName = StringUtil.upperFirst(parameter.name);
        final String tabs = getTabString(templateData);

        for (int i = 0; i < 3; ++i) {
            //Write the beginning of the method declaration.
            printStream.printf("%s\tpublic %s get%s%s(", tabs, returnType, upperName, minMaxNames[i]);
            printMethodArguments(printStream, parameter);
            printStream.printf(") {\n");
            printMethodBase(printStream, templateData);
            printMethodReturnBaseValue(printStream, tabs, parameter, minMaxNames[i]);
            printStream.printf("%s\t\t%s value = this.%s%s.get%sValue();\n",
                    tabs, returnType, parameter.name, arrayAccessor, minMaxNames[i]);

            if ((parameter.type == ParamType.INTEGER || parameter.type == ParamType.FLOAT)
                    && parameter.listType != ListType.LIST) {
                printStream.printf("%s\t\tfinal byte delta = this.%s%s.getDeltaType();\n", tabs, parameter.name, arrayAccessor);
                printStream.println();
                printStream.printf("%s\t\tif (delta == '+' || delta == '-' || delta == '_' || delta == '=') {\n", tabs);
                printStream.printf("%s\t\t\t%s baseValue = 0;\n", tabs, returnType);
                printStream.println();
                printStream.printf("%s\t\t\t\tif (baseData != null) {\n", tabs);
                printStream.printf("%s\t\t\t\t\tif (base != null)\n", tabs);
                printStream.printf("%s\t\t\t\t\t\tbaseValue = base.get%s%s(%s);\n", tabs, upperName, minMaxNames[i], indexString);
                printStream.printf("%s\t\t\t\t}\n", tabs);
                printStream.println();
                printStream.printf("%s\t\t\tif (delta == '+')\n", tabs);
                printStream.printf("%s\t\t\t\tvalue = baseValue + value;\n", tabs);
                printStream.printf("%s\t\t\tif (delta == '-')\n", tabs);
                printStream.printf("%s\t\t\t\tvalue = baseValue - value;\n", tabs);
                printStream.printf("%s\t\t\tif (delta == '=')\n", tabs);
                printStream.printf("%s\t\t\t\tvalue = baseValue + (%s)(baseValue * (value / 100.0f));\n", tabs, returnType);
                printStream.printf("%s\t\t\tif (delta == '_')\n", tabs);
                printStream.printf("%s\t\t\t\tvalue = baseValue - (%s)(baseValue * (value / 100.0f));\n", tabs, returnType);
                printStream.printf("%s\t\t}\n", tabs);
            }

            printStream.printf("%s\t\treturn value;\n", tabs);
            printStream.printf("%s\t}\n", tabs);
            printStream.println();

            if (!hasMinMax[parameter.type.ordinal()])
                break;
        }
    }

    private void printMethodForVectorParameter(final PrintStream printStream, final TemplateData templateData, final Parameter parameter) {
    }

    private void printMethodForDynamicVariableParameter(final PrintStream printStream, final TemplateData templateData, final Parameter parameter) {
    }

    private void printMethodForTemplateParameter(final PrintStream printStream, final TemplateData templateData, final Parameter parameter) {
        final String tabs = getTabString(templateData);
        final String templateName = templateData.getTemplateLocation().getName()
                + StringUtil.convertUnderscoreToUpper(parameter.extendedName);
        final String arrayAccessor = getArrayAccessor(parameter.listType);
        final String upperName = StringUtil.upperFirst(parameter.name);

        printStream.printf("%s\tpublic %s get%s(", tabs, templateName, upperName);
        printMethodArguments(printStream, parameter);
        printStream.printf(") {\n");

        printMethodBase(printStream, templateData);
        printMethodReturnBaseValue(printStream, tabs, parameter, "");

        printStream.printf("%s\t\t%s returnValue = null;\n", tabs, templateName);

        if (parameter.listType == ListType.NONE) {
            printStream.printf("%s\t\tfinal String templateName = %s.getValue();\n", tabs, parameter.name);
        } else {
            printStream.printf("%s\t\tfinal String templateName = %s[%s].getValue();\n", tabs, parameter.name, arrayAccessor);
        }

        printStream.println();
        printStream.printf("%s\t\tif (!templateName.isEmpty()) {\n", tabs);
        printStream.printf("%s\t\t\treturnValue = objectTemplateList.fetch(templateName);\n", tabs);
        printStream.println();
        printStream.printf("%s\t\t\t if (returnValue == null)\n", tabs);
        printStream.printf("%s\t\t\t\tthrow new IllegalStateException(String.format(\"error loading template %%s\", templateName));\n", tabs);
        printStream.printf("%s\t\t}\n", tabs);
        printStream.println();
        printStream.printf("%s\t\treturn returnValue;\n", tabs);

        printStream.printf("%s\t}\n", tabs);
        printStream.println();
    }

    private void printMethodForEnumParameter(final PrintStream printStream, final TemplateData templateData, final Parameter parameter) {
        final String tabs = getTabString(templateData);
        final String arrayAccessor = getArrayAccessor(parameter.listType);
        final String upperName = StringUtil.upperFirst(parameter.name);

        printStream.printf("%s\tpublic %s get%s(", tabs, parameter.extendedName, upperName);
        printMethodArguments(printStream, parameter);
        printStream.printf(") {\n");

        printMethodBase(printStream, templateData);
        printMethodReturnBaseValue(printStream, tabs, parameter, "");

        if (parameter.listType == ListType.NONE) {
            printStream.printf("%s\t\treturn %s.from(%s.getValue());\n",
                    tabs, parameter.extendedName, parameter.name);
        } else {
            printStream.printf("%s\t\treturn %s.from(%s%s.getValue());\n",
                    tabs, parameter.extendedName, parameter.name, arrayAccessor);
        }

        printStream.printf("%s\t}\n", tabs);
        printStream.println();
    }

    private void printMethodForStructParameter(final PrintStream printStream, final TemplateData templateData, final Parameter parameter) {
        final String tabs = getTabString(templateData);
        final String arrayAccessor = getArrayAccessor(parameter.listType);
        final String upperName = StringUtil.upperFirst(parameter.name);

        for (int i = 0; i < 3; ++i) {
            printStream.printf("%s\tpublic %s get%s%s(", tabs, parameter.extendedName, upperName, minMaxNames[i]);
            printMethodArguments(printStream, parameter);
            printStream.printf(") {\n");

            printMethodBase(printStream, templateData);
            printMethodReturnBaseValue(printStream, tabs, parameter, minMaxNames[i]);

            printStream.printf("%s\t\tfinal ObjectTemplate structTemplate = %s%s.getValue();\n",
                    tabs, parameter.name, arrayAccessor);

            printStream.printf("%s\t\tPreconditions.checkNotNull(structTemplate);\n", tabs);
            printStream.printf("%s\t\tfinal %sObjectTemplate param = (%sObjectTemplate)structTemplate;\n",
                    tabs, parameter.extendedName, parameter.extendedName);
            printStream.println();

            final TemplateData structData = templateData.getStruct(parameter.extendedName);

            if (structData == null)
                throw new IllegalStateException(String.format("Unable to find structure %s.", parameter.extendedName));

            printStream.printf("%s\t\tfinal %s data = new %s();\n",
                    tabs, parameter.extendedName, parameter.extendedName);

            printStructAssignments(printStream, structData, minMaxNames[i]);

            printStream.println();
            printStream.printf("%s\t\treturn data;\n", tabs);
            printStream.printf("%s\t}\n", tabs);
            printStream.println();

            if (!hasMinMax[parameter.type.ordinal()])
                break;
        }
    }

    private void printMethodBase(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        final String templateName = templateData.templateParent == null
                ? templateData.getName()
                : templateData.getName() + "ObjectTemplate";

        printStream.printf("%s\t\t%s base = null;\n", tabs, templateName);
        printStream.println();
        printStream.printf("%s\t\tif (baseData instanceof %s)\n", tabs, templateName);
        printStream.printf("%s\t\t\tbase = (%s)baseData;\n", tabs, templateName);
        printStream.println();
    }

    private void printMethodReturnBaseValue(final PrintStream printStream, final String tabs, final Parameter parameter, final String suffix) {
        final String upperName = StringUtil.upperFirst(parameter.name);
        final String defaultDataType = defaultDataReturnTypes[parameter.type.ordinal()];
        final String indexString = parameter.listType != ListType.NONE ? "index" : "";

        if (parameter.listType == ListType.NONE)
            printStream.printf("%s\t\tif (!%s.isLoaded()) {\n", tabs, parameter.name);
        else if (parameter.listType == ListType.LIST)
            printStream.printf("%s\t\tif (!%sLoaded) {\n", tabs, parameter.name);
        else if (parameter.listType == ListType.ENUM_ARRAY)
            printStream.printf("%s\t\tif (!%s[(int)index.value].isLoaded()) {\n", tabs, parameter.name);
        else
            printStream.printf("%s\t\tif (!%s[index].isLoaded()) {\n", tabs, parameter.name);

        if (defaultDataType != null) {
            printStream.printf("%s\t\t\tif (base == null) {\n", tabs);

            if (parameter.type == ParamType.ENUM) {
                printStream.printf("%s\t\t\t\treturn %s.from%s;\n",
                        tabs,
                        parameter.extendedName,
                        defaultDataType);
            } else {
                printStream.printf("%s\t\t\t\treturn %s;\n", tabs, defaultDataType);
            }

            printStream.printf("%s\t\t\t} else {\n", tabs);
            printStream.printf("%s\t\t\t\treturn base.get%s%s(%s);\n", tabs, upperName, suffix, indexString);
            printStream.printf("%s\t\t\t}\n", tabs);
        } else {
            printStream.printf("%s\t\t\tPreconditions.checkNotNull(base);\n", tabs);
            printStream.printf("%s\t\t\treturn base.get%s%s(%s);\n", tabs, upperName, suffix, indexString);
        }

        printStream.printf("%s\t\t}\n", tabs);
        printStream.println();

        if (parameter.listType == ListType.LIST) {
            printStream.printf("%s\t\tif (%sAppend && base != null) {\n", tabs, parameter.name);
            printStream.printf("%s\t\t\tint baseCount = base.get%sCount();\n", tabs, upperName);
            printStream.println();
            printStream.printf("%s\t\t\tif (index < baseCount) {\n", tabs);
            printStream.printf("%s\t\t\t\treturn base.get%s%s(%s);\n", tabs, upperName, suffix, indexString);
            printStream.printf("%s\t\t\t}\n", tabs);
            printStream.printf("%s\t\t\tindex -= baseCount;\n", tabs);
            printStream.printf("%s\t\t}\n", tabs);
        }
    }

    private void printLoadMethod(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        printStream.printf("%s\t@Override\n", tabs);
        printStream.printf("%s\tprotected void load(final Iff iff) {\n", tabs);

        if (templateData.fileParent != null) {
            printStream.printf("%s\t\tif (iff.getCurrentName() != TAG_%s) {\n", tabs, templateData.getName().toUpperCase());

            final String baseName = templateData.getBaseName();

            if (baseName != null && !baseName.isEmpty() && !TemplateUtil.ROOT_TEMPLATE_NAME.equals(baseName)) {
                printStream.printf("%s\t\t\tsuper.load(iff);\n", tabs);
            }

            printStream.printf("%s\t\t\treturn;\n", tabs);
            printStream.printf("%s\t\t}\n", tabs);
            printStream.println();
            printStream.printf("%s\t\tiff.enterForm();\n", tabs);
            printStream.printf("%s\t\ttemplateVersion = iff.getCurrentName();\n", tabs);
            printStream.println();
            printStream.printf("%s\t\tif (templateVersion == Tag.TAG_DERV) {\n", tabs);
            printStream.printf("%s\t\t\tiff.enterForm();\n", tabs);
            printStream.printf("%s\t\t\tiff.enterChunk();\n", tabs);
            printStream.printf("%s\t\t\tfinal String baseFilename = iff.readString();\n", tabs);
            printStream.printf("%s\t\t\tiff.exitChunk();\n", tabs);
            printStream.printf("%s\t\t\tfinal ObjectTemplate base = objectTemplateList.fetch(baseFilename);\n", tabs);
            printStream.printf("%s\t\t\tPreconditions.checkNotNull(base, \"was unable to load base template %%s\", baseFilename);\n", tabs);
            printStream.printf("%s\t\t\tif (baseData == base && base != null) {\n", tabs);
            printStream.printf("%s\t\t\t\tbase.releaseReference();\n", tabs);
            printStream.printf("%s\t\t\t} else {\n", tabs);
            printStream.printf("%s\t\t\t\tif (baseData != null)\n", tabs);
            printStream.printf("%s\t\t\t\t\tbaseData.releaseReference();\n", tabs);
            printStream.printf("%s\t\t\t\tbaseData = base;\n", tabs);
            printStream.printf("%s\t\t\t}\n", tabs);
            printStream.printf("%s\t\t\tiff.exitForm();\n", tabs);
            printStream.printf("%s\t\t\ttemplateVersion = iff.getCurrentName();\n", tabs);
            printStream.printf("%s\t\t}\n", tabs);
            printStream.println();
        }

        //Loading of parameters
        printStream.printf("%s\t\tiff.enterForm();\n", tabs);
        printStream.printf("%s\t\tiff.enterChunk();\n", tabs);
        printStream.printf("%s\t\tfinal int paramCount = iff.readInt();\n", tabs);
        printStream.printf("%s\t\tiff.exitChunk();\n", tabs);

        if (templateData.parameters.size() > 0) {
            printStream.printf("%s\t\tfor (int i = 0; i < paramCount; ++i) {\n", tabs);
            printStream.printf("%s\t\t\tiff.enterChunk();\n", tabs);
            printStream.printf("%s\t\t\tfinal String parameterName = iff.readString();\n", tabs);
            printStream.println();
            printStream.printf("%s\t\t\t", tabs);

            templateData.parameters.stream()
                    .filter(parameter -> parameter.type != ParamType.COMMENT && parameter.type != ParamType.NONE)
                    .forEach(parameter -> printParameterLoad(printStream, tabs, parameter));

            printStream.printf(" {\n");
            printStream.printf("%s\t\t\t\tLOGGER.trace(\"Unexpected parameter {}\", parameterName);\n", tabs);
            printStream.printf("%s\t\t\t}\n", tabs);
            printStream.println();
            printStream.printf("%s\t\t\tiff.exitChunk();\n", tabs);
            printStream.printf("%s\t\t}\n", tabs);
        }

        printStream.printf("%s\t\tiff.exitForm();\n", tabs);

        if (templateData.fileParent != null) {
            final String baseName = templateData.getBaseName();

            if (baseName != null && !baseName.isEmpty() && !TemplateUtil.ROOT_TEMPLATE_NAME.equals(baseName)) {
                printStream.println();
                printStream.printf("%s\t\tsuper.load(iff);\n", tabs);
                printStream.printf("%s\t\tiff.exitForm();\n", tabs);
            }
        }

        printStream.printf("%s\t}\n", tabs);
        printStream.println();
    }

    private void printParameterLoad(final PrintStream printStream, final String tabs, final Parameter parameter) {
        final String dataVariableName = dataVariableNames[parameter.type.ordinal()];

        printStream.printf("if (\"%s\".equalsIgnoreCase(parameterName)) {\n", parameter.name);

        switch (parameter.listType) {
            case NONE:
                printStream.printf("%s\t\t\t\t%s.loadFromIff(objectTemplateList, iff);\n", tabs, parameter.name);
                break;

            case LIST:
                printStream.printf("%s\t\t\t\t%s.clear();\n", tabs, parameter.name);
                printStream.printf("%s\t\t\t\t%sAppend = iff.readBoolean();\n", tabs, parameter.name);
                printStream.printf("%s\t\t\t\tint listCount = iff.readInt();\n", tabs);
                printStream.printf("%s\t\t\t\tfor (int j = 0; j < listCount; ++j) {\n", tabs);
                printStream.printf("%s\t\t\t\t\tfinal %s newData = new %s();\n", tabs, dataVariableName, dataVariableName);
                printStream.printf("%s\t\t\t\t\tnewData.loadFromIff(objectTemplateList, iff);\n", tabs);
                printStream.printf("%s\t\t\t\t\t%s.add(newData);\n", tabs, parameter.name);
                printStream.printf("%s\t\t\t\t}\n", tabs);
                printStream.printf("%s\t\t\t\t%sLoaded = true;\n", tabs, parameter.name);
                break;

            case ENUM_ARRAY:
            case INT_ARRAY:
                printStream.printf("%s\t\t\t\tint listCount = iff.readInt();\n", tabs);
                //Warning about wrong array size.
                printStream.printf("%s\t\t\t\tint j;\n", tabs);
                printStream.printf("%s\t\t\t\tfor (j = 0; j < %d && j < listCount; ++j)\n", tabs, parameter.listSize);
                printStream.printf("%s\t\t\t\t\t%s[j].loadFromIff(objectTemplateList, iff);\n", tabs, parameter.name);
                printStream.printf("%s\t\t\t\tfor (; j < listCount; ++j) {\n", tabs);
                printStream.printf("%s\t\t\t\t\tfinal %s dummy = new %s();\n", tabs, dataVariableName, dataVariableName);
                printStream.printf("%s\t\t\t\t\tdummy.loadFromIff(objectTemplateList, iff);\n", tabs);
                printStream.printf("%s\t\t\t\t}\n", tabs);
                break;
        }

        printStream.printf("%s\t\t\t} else ", tabs);
    }

    private void printSaveMethod(final PrintStream printStream, final TemplateData templateData) {

    }

    private void printEnums(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        for (final Map.Entry<String, List<EnumData>> entry : templateData.enumMap.entrySet()) {
            final String enumName = entry.getKey();

            //Print out the enum name.
            printStream.printf("%s\tpublic enum %s {\n", tabs, enumName);

            //Print out the members of the enum.
            final List<EnumData> enumList = entry.getValue();
            final int count = enumList.size();

            for (int i = 0; i < count; ++i) {
                final EnumData data = enumList.get(i);

                printStream.printf("%s\t\t%s(%s), %s\n",
                        tabs,
                        data.name,
                        data.valueName != null ? data.valueName : data.value,
                        fixComment(data.comment));
            }

            printStream.printf("%s\t\t%s_Last(%s.value);\n", tabs, enumName, enumList.get(enumList.size() - 1).name);

            //Helper methods for each enum.
            printStream.println();
            printStream.printf("%s\t\tprivate static final %s[] values = values();\n", tabs, enumName);
            printStream.printf("%s\t\tpublic final long value;\n", tabs);
            printStream.printf("%s\t\t%s(final long value) { this.value = value; }\n", tabs, enumName);
            printStream.printf("%s\t\tpublic static %s from(final long value) {\n", tabs, enumName);
            printStream.printf("%s\t\t\tfor (final %s e : values)\n", tabs, enumName);
            printStream.printf("%s\t\t\t\tif (e.value == value) return e;\n", tabs);
            printStream.printf("%s\t\t\tthrow new IllegalArgumentException(String.format(\"UNKNOWN value %%d for enum %s\", value));\n", tabs, enumName);
            printStream.printf("%s\t\t}\n", tabs);

            //Closing for enum.
            printStream.printf("%s\t}\n", tabs);
            printStream.println();
        }
    }

    private void printStructs(final PrintStream printStream, final TemplateData templateData) {
        for (final TemplateData struct : templateData.structList) {
            //Print the POJO.
            printStream.printf("\tpublic static class %s {\n", struct.getName());

            //Parameter declarations.
            for (final Parameter parameter : struct.parameters) {
                final String dataMethodName = dataMethodNames[parameter.type.ordinal()];
                final String typeName = dataMethodName == null ? parameter.extendedName : dataMethodName;

                switch (parameter.listType) {
                    case NONE:
                    case INT_ARRAY:
                    case ENUM_ARRAY:
                        printStream.printf("\t\t@Getter protected %s %s", typeName, parameter.name);

                        if (parameter.listType != ListType.NONE)
                            printStream.printf("[] = new %s[%d]", typeName, parameter.listSize);

                        printStream.printf(";\n");
                        break;
                    case LIST:
                        printStream.printf("\t\tprotected List<%s> %s = new ArrayList<>(%d);\n",
                                typeName, parameter.name, parameter.listSize);
                        break;
                    default:
                        break;
                }
            }

            printStream.printf("\t}\n");
            printStream.println();

            //Print the object template declaration.
            printClassDeclarationOpening(printStream, struct);
            printTemplateTag(printStream, struct);
            printConstructors(printStream, struct);
            printFields(printStream, struct);
            printMethods(printStream, struct);
            printLoadMethod(printStream, struct);
            printClassDeclarationClosing(printStream, struct);
        }
    }

    private void printStructAssignments(final PrintStream printStream, final TemplateData templateData, final String suffix) {
        final String tabs = getTabString(templateData);

        for (final Parameter parameter : templateData.parameters) {
            if (parameter.type == ParamType.NONE || parameter.type == ParamType.COMMENT)
                continue;

            final String parameterUpperName = StringUtil.upperFirst(parameter.name);
            final String realSuffix = hasMinMax[parameter.type.ordinal()] ? suffix : "";

            switch (parameter.listType) {
                case NONE:
                    printStream.printf("%s\t\tdata.%s = param.get%s%s();\n",
                            tabs, parameter.name, parameterUpperName, realSuffix);
                    break;
                case LIST:
                    printStream.printf("%s\t\tfor (int i = 0; i < param.get%sCount(); ++i)\n", tabs, parameterUpperName);
                    printStream.printf("%s\t\t\tdata.%s.add(param.get%s%s(i));\n",
                            tabs, parameter.name, parameterUpperName, realSuffix);
                    break;
                case INT_ARRAY:
                    printStream.printf("%s\t\tfor (int i = 0; i < %d; ++i)\n", tabs, parameter.listSize);
                    printStream.printf("%s\t\t\tdata.%s[i] = param.get%s%s(i);\n",
                            tabs, parameter.name, parameterUpperName, realSuffix);
                    break;
                case ENUM_ARRAY:
                    printStream.printf("%s\t\tfor (int i = 0; i < %d; ++i)\n", tabs, parameter.listSize);
                    printStream.printf("%s\t\t\tdata.%s[i] = param.get%s%s(%s.from(i));\n",
                            tabs, parameter.name, parameterUpperName, realSuffix, parameter.enumListName);
                    break;
                default:
                    break;
            }
        }
    }

    private void printClassDeclarationClosing(final PrintStream printStream, final TemplateData templateData) {
        final String tabs = getTabString(templateData);

        printStream.printf("%s}\n", tabs);
        printStream.println();
    }

    private String fixComment(final String comment) {
        if (comment == null)
            return "";

        if (comment.startsWith("//"))
            return comment;

        return "//" + comment;
    }

    private String getArrayAccessor(final ListType listType) {
        switch (listType) {
            case LIST:
                return ".get(index)";
            case INT_ARRAY:
                return "[index]";
            case ENUM_ARRAY:
                return "[(int)index.value]";
            default:
            case NONE:
                return "";
        }
    }

    private int getTemplateDepth(final TemplateData templateData) {
        int depth = 0;
        TemplateData current = templateData;

        while ((current = current.templateParent) != null)
            ++depth;

        return depth;
    }

    private String getTabString(final TemplateData templateData) {
        int depth = getTemplateDepth(templateData);
        final char[] tabs = new char[depth];
        Arrays.fill(tabs, '\t');
        return new String(tabs);
    }

    private static final String[] includes = new String[]{
            "lombok.Getter",
            "io.bacta.shared.iff.Iff",
            "com.google.common.base.Preconditions",
            "io.bacta.shared.foundation.Tag",
            "io.bacta.shared.foundation.DataResourceList",
            "io.bacta.shared.localization.StringId",
            "io.bacta.shared.template.ObjectTemplate",
            "io.bacta.template.definition.TemplateDefinition",
            "io.bacta.shared.utility.BoolParam",
            "io.bacta.shared.utility.FloatParam",
            "io.bacta.shared.utility.StringParam",
            "io.bacta.shared.utility.StructParam",
            "io.bacta.shared.utility.VectorParam",
            "io.bacta.shared.utility.VectorParamData",
            "io.bacta.shared.utility.IntegerParam",
            "io.bacta.shared.utility.StringIdParam",
            "io.bacta.shared.utility.StringIdParamData",
            "io.bacta.shared.utility.TriggerVolumeData",
            "io.bacta.shared.utility.TriggerVolumeParam",
            "io.bacta.shared.utility.TriggerVolumeParamData",
            "io.bacta.shared.utility.DynamicVariableParam",
            "io.bacta.shared.utility.DynamicVariableParamData",
            "java.util.ArrayList",
            "java.util.List",
            "org.slf4j.Logger",
            "org.slf4j.LoggerFactory"
    };

    private static final String[] dataVariableNames = new String[]{
            "",
            "",
            "IntegerParam",
            "FloatParam",
            "BoolParam",
            "StringParam",
            "StringIdParam",
            "VectorParam",
            "DynamicVariableParam",
            "StringParam",
            "IntegerParam",
            "StructParam<ObjectTemplate>",
            "TriggerVolumeParam",
            "StringParam"
    };

    private static final String[] dataMethodNames = new String[]{
            null,
            null,
            "int",
            "float",
            "boolean",
            "String",
            "StringId",
            "Vector",
            "void",
            "ObjectTemplate",
            null,
            null,
            "TriggerVolumeData",
            "String"
    };

    private static final String[] defaultDataReturnTypes = new String[]{
            null,
            null,
            "0",
            "0.0f",
            "false",
            "\"\"",
            "StringId.INVALID",
            "DefaultVector",
            "",
            "null",
            "(0)",
            "null",
            "new TriggerVolumeData()",
            "null"
    };

    private static final boolean[] hasMinMax = new boolean[]{
            false,
            false,
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false
    };

    private static final String[] minMaxNames = new String[]{"", "Min", "Max"};
}
